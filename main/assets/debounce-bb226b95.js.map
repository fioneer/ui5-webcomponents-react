{"version":3,"file":"debounce-bb226b95.js","sources":["../../packages/base/src/hooks/useIsRTL.ts","../../packages/base/src/utils/debounce.ts"],"sourcesContent":["'use client';\n\nimport { getRTL } from '@ui5/webcomponents-base/dist/config/RTL.js';\nimport type { RefObject } from 'react';\nimport { useRef, useState } from 'react';\nimport { useIsomorphicLayoutEffect } from '../hooks/index.js';\n\nconst GLOBAL_DIR_CSS_VAR = '--_ui5_dir';\n\nconst detectRTL = <RefType extends HTMLElement>(elementRef: RefObject<RefType>) => {\n  if (!elementRef.current) {\n    return getRTL();\n  }\n  const doc = window.document;\n  const dirValues = ['ltr', 'rtl']; // exclude \"auto\" and \"\" from all calculations\n  const locallyAppliedDir = getComputedStyle(elementRef.current).getPropertyValue(GLOBAL_DIR_CSS_VAR);\n\n  // In that order, inspect the CSS Var (for modern browsers), the element itself, html and body (for IE fallback)\n  if (dirValues.includes(locallyAppliedDir)) {\n    return locallyAppliedDir === 'rtl';\n  }\n  if (dirValues.includes(elementRef.current?.dir)) {\n    return elementRef.current?.dir === 'rtl';\n  }\n  if (dirValues.includes(doc.documentElement.dir)) {\n    return doc.documentElement.dir === 'rtl';\n  }\n  if (dirValues.includes(doc.body.dir)) {\n    return doc.body.dir === 'rtl';\n  }\n\n  // Finally, check the configuration for explicitly set RTL or language-implied RTL\n  return getRTL();\n};\n\nconst useIsRTL = <RefType extends HTMLElement>(elementRef: RefObject<RefType>): boolean => {\n  const [isRTL, setRTL] = useState<boolean>(getRTL()); // use config RTL as best guess\n  const isMounted = useRef(false);\n  useIsomorphicLayoutEffect(() => {\n    isMounted.current = true;\n    setRTL(detectRTL(elementRef)); // update immediately while rendering\n    const targets = [document.documentElement, document.body, elementRef.current].filter(Boolean);\n    const observer = new MutationObserver((mutations) => {\n      mutations.forEach((mutation) => {\n        if (mutation.attributeName === 'dir') {\n          if (isMounted.current) {\n            setRTL(detectRTL(elementRef));\n          }\n        }\n      });\n    });\n\n    targets.forEach((target) => {\n      // @ts-expect-error: target can never be a faulty value\n      observer.observe(target, {\n        attributes: true,\n        childList: false,\n        characterData: false,\n        attributeFilter: ['dir']\n      });\n    });\n\n    return () => {\n      isMounted.current = false;\n      observer.disconnect();\n    };\n  }, [isMounted, elementRef.current]);\n\n  return isRTL;\n};\n\nexport { useIsRTL };\n","// Copied from https://github.com/jashkenas/underscore/blob/master/modules/debounce.js (31th May 2021)\n\nconst now = Date.now || (() => new Date().getTime());\n\ninterface Cancelable {\n  cancel(): void;\n}\n\n/**\n * When a sequence of calls of the returned function ends, the argument\n * function is triggered. The end of a sequence is defined by the `wait`\n * parameter.\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nconst debounce = <T extends Function>(func: T, wait: number): T & Cancelable => {\n  let timeout;\n  let previous;\n  let args;\n  let result;\n  let context;\n\n  const later = () => {\n    const passed = now() - previous;\n    if (wait > passed) {\n      timeout = setTimeout(later, wait - passed);\n    } else {\n      timeout = null;\n      result = func.apply(context, args);\n      // This check is needed because `func` can recursively invoke `debounced`.\n      if (!timeout) args = context = null;\n    }\n  };\n\n  const debounced = function (..._args: unknown[]) {\n    // @ts-expect-error: copied - no need to infer types here\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    context = this;\n    args = _args;\n    previous = now();\n    if (!timeout) {\n      timeout = setTimeout(later, wait);\n    }\n    return result;\n  };\n\n  debounced.cancel = () => {\n    clearTimeout(timeout);\n    timeout = args = context = null;\n  };\n\n  // @ts-expect-error: copied - no need to infer types here\n  return debounced;\n};\n\nexport { debounce };\n"],"names":["GLOBAL_DIR_CSS_VAR","detectRTL","elementRef","getRTL","doc","dirValues","locallyAppliedDir","_a","_b","useIsRTL","isRTL","setRTL","useState","isMounted","useRef","useIsomorphicLayoutEffect","targets","observer","mutations","mutation","target","now","debounce","func","wait","timeout","previous","args","result","context","later","passed","debounced","_args"],"mappings":"iJAOA,MAAMA,EAAqB,aAErBC,EAA0CC,GAAmC,SAC7E,GAAA,CAACA,EAAW,QACd,OAAOC,EAAO,EAEhB,MAAMC,EAAM,OAAO,SACbC,EAAY,CAAC,MAAO,KAAK,EACzBC,EAAoB,iBAAiBJ,EAAW,OAAO,EAAE,iBAAiBF,CAAkB,EAG9F,OAAAK,EAAU,SAASC,CAAiB,EAC/BA,IAAsB,MAE3BD,EAAU,UAASE,EAAAL,EAAW,UAAX,YAAAK,EAAoB,GAAG,IACrCC,EAAAN,EAAW,UAAX,YAAAM,EAAoB,OAAQ,MAEjCH,EAAU,SAASD,EAAI,gBAAgB,GAAG,EACrCA,EAAI,gBAAgB,MAAQ,MAEjCC,EAAU,SAASD,EAAI,KAAK,GAAG,EAC1BA,EAAI,KAAK,MAAQ,MAInBD,EAAO,CAChB,EAEMM,EAAyCP,GAA4C,CACzF,KAAM,CAACQ,EAAOC,CAAM,EAAIC,EAAAA,SAAkBT,EAAQ,CAAA,EAC5CU,EAAYC,SAAO,EAAK,EAC9B,OAAAC,EAA0B,IAAM,CAC9BF,EAAU,QAAU,GACbF,EAAAV,EAAUC,CAAU,CAAC,EACtB,MAAAc,EAAU,CAAC,SAAS,gBAAiB,SAAS,KAAMd,EAAW,OAAO,EAAE,OAAO,OAAO,EACtFe,EAAW,IAAI,iBAAkBC,GAAc,CACzCA,EAAA,QAASC,GAAa,CAC1BA,EAAS,gBAAkB,OACzBN,EAAU,SACLF,EAAAV,EAAUC,CAAU,CAAC,CAEhC,CACD,CAAA,CACF,EAEO,OAAAc,EAAA,QAASI,GAAW,CAE1BH,EAAS,QAAQG,EAAQ,CACvB,WAAY,GACZ,UAAW,GACX,cAAe,GACf,gBAAiB,CAAC,KAAK,CAAA,CACxB,CAAA,CACF,EAEM,IAAM,CACXP,EAAU,QAAU,GACpBI,EAAS,WAAW,CAAA,CAErB,EAAA,CAACJ,EAAWX,EAAW,OAAO,CAAC,EAE3BQ,CACT,ECnEMW,EAAM,KAAK,MAAQ,IAAU,IAAA,OAAO,QAAQ,GAY5CC,EAAW,CAAqBC,EAASC,IAAiC,CAC1E,IAAAC,EACAC,EACAC,EACAC,EACAC,EAEJ,MAAMC,EAAQ,IAAM,CACZ,MAAAC,EAASV,EAAQ,EAAAK,EACnBF,EAAOO,EACCN,EAAA,WAAWK,EAAON,EAAOO,CAAM,GAE/BN,EAAA,KACDG,EAAAL,EAAK,MAAMM,EAASF,CAAI,EAE5BF,IAASE,EAAOE,EAAU,MACjC,EAGIG,EAAY,YAAaC,EAAkB,CAGrC,OAAAJ,EAAA,KACHF,EAAAM,EACPP,EAAWL,EAAI,EACVI,IACOA,EAAA,WAAWK,EAAON,CAAI,GAE3BI,CAAA,EAGT,OAAAI,EAAU,OAAS,IAAM,CACvB,aAAaP,CAAO,EACpBA,EAAUE,EAAOE,EAAU,IAAA,EAItBG,CACT"}